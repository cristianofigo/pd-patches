#N canvas 41 4 929 645 10;
#N canvas 0 0 450 300 Maxlib_random_generators 0;
#X text 30 34 RANDOM;
#X obj 30 58 gauss;
#X obj 30 83 poisson;
#X obj 96 58 linear;
#X obj 96 83 bilex;
#X obj 166 57 expo;
#X obj 223 57 beta;
#X obj 278 58 cauchy;
#X obj 167 84 arbran array01 array02;
#X obj 29 112 urn;
#X text 62 112 urn selection model;
#X text 28 186 If these objects create \, then you have Maxlib installed.
Right click on them for the help files.;
#X restore 465 47 pd Maxlib_random_generators;
#X text 462 10 If you have the Maxlib external \, you can use a wider
range of random generators:;
#X text 777 617 derek@umatic.nl;
#X obj 25 82 random 100;
#X obj 25 63 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X floatatom 25 103 3 0 0 0 - - -;
#X text 130 82 Generates random numbers between 0 and 99;
#X obj 25 143 random 100;
#X obj 25 124 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X floatatom 25 164 3 0 0 0 - - -;
#X floatatom 90 126 5 0 0 0 - - -;
#X text 131 124 Changes the 'range' of random numbers.;
#X msg 25 419 bang;
#X text 22 352 You can generate weighted random numbers from uniformly
distributed ones. If you just want two possible outcomes with a varying
probability for each one \, you can do as shown:;
#X obj 25 445 random 100;
#X obj 25 498 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 91 498 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X floatatom 127 472 3 0 100 0 - - -;
#X text 172 462 <-- change probablilty;
#X obj 25 473 moses 80;
#X text 74 417 <-- click to test;
#X text 458 353 This outputs a number at left 80% of the time \, otherwise
at right \, unless you override the "80" using the number box. You
may extend this to more than two possible outcomes \, for instance
like this:;
#X msg 461 418 bang;
#X obj 461 444 random 100;
#X obj 461 497 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 551 498 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X text 510 416 <-- click to test;
#X obj 461 472 moses 10;
#X obj 551 473 moses 30;
#X obj 619 498 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X text 459 513 10%;
#X text 549 514 20%;
#X text 621 513 70%;
#X text 458 599 http://www.davesabine.com/media/puredata_pddpfiles.asp
;
#X text 457 542 This document was adapted from the Pure Data Documentation
Project \, updated for PD version 0.35 test 29 by Dave Sabine as part
of a project called pddp proposed by Krzysztof Czaja to build comprehensive
documentation for PD.;
#N canvas 0 0 585 687 random_seeds 0;
#X text 19 16 SEEDS;
#X text 23 33 Random numbers are generated via a complex equation which
produces a pseudo-predictable sequence of numbers. Each [random] object's
equation is provided with a "seed" which is really just one of the
variables in the equation which produces the sequence. The "seed" is
generated by PD based on specific parameters in each patch which contains
a [random] object. If more than one [random] objects are contained
within a single patch \, they each get a different "seed".;
#X text 23 156 However \, "seeds" can be inputted into [random] by
sending a message \, like below:;
#X msg 15 213 seed 42;
#X obj 69 220 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 69 238 random 1000;
#X floatatom 69 258 3 0 0 0 - - -;
#X obj 15 193 loadbang;
#X text 24 283 Seeds are kept locally so that if two [random]s are
seeded the same \, they will have the same output - as demonstrated
below. Furthermore \, you can seed the same one twice to repeat the
output.;
#X msg 172 349 seed 42;
#X obj 78 352 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 78 384 random 1000;
#X floatatom 78 404 3 0 0 0 - - -;
#X obj 172 329 loadbang;
#X obj 172 384 random 1000;
#X floatatom 172 404 3 0 0 0 - - -;
#X text 225 349 Click again to repeat output.;
#X text 28 438 FERTILE SEEDS!;
#X text 19 459 While the "default" seed for each [random] is usually
very effective \, it may be necessary to find better - more unpredictable
- more indeterminate ways to seed the object to produce a more pleasing
result.;
#X text 18 564 Here are some ideas that may improve the implementation
of [random]:;
#X floatatom 196 661 0 0 0 0 - - -;
#X obj 38 602 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 196 641 / 100;
#X floatatom 38 658 0 0 0 0 - - -;
#X text 58 601 Both methods here produce random numbers between 0 and
5;
#X obj 196 621 random 501;
#X obj 38 638 random 6;
#X text 263 621 0 - 500;
#X text 234 641 divide by 100 to keep output within range.;
#X text 234 662 produces fractional results between 0 and 5;
#X text 35 689 between 0 and 5;
#X text 35 676 Produces whole numbers;
#X text 4 599 1;
#X text 19 514 As well \, there are many ways that [random] can be
incorporated into other structures that change the qualities of the
results.;
#X obj 39 735 loadbang;
#X obj 39 757 timer;
#X obj 121 738 bng 15 250 50 0 empty empty Click_to_seed 0 -6 0 7 -262144
-1 -1;
#X msg 39 777 seed \$1;
#X obj 100 780 bng 15 250 50 0 empty empty Click_for_output 0 -6 0
7 -262144 -1 -1;
#X floatatom 100 820 5 0 0 0 - - -;
#X obj 100 799 random 42;
#X text 201 737 "Time is on your side". Using the [timer] object here
(which is started via loadbang) is an interesting trick.;
#X text 3 737 2;
#X connect 3 0 5 0;
#X connect 4 0 5 0;
#X connect 5 0 6 0;
#X connect 7 0 3 0;
#X connect 9 0 11 0;
#X connect 9 0 14 0;
#X connect 10 0 11 0;
#X connect 10 0 14 0;
#X connect 11 0 12 0;
#X connect 13 0 9 0;
#X connect 14 0 15 0;
#X connect 21 0 25 0;
#X connect 21 0 26 0;
#X connect 22 0 20 0;
#X connect 25 0 22 0;
#X connect 26 0 23 0;
#X connect 34 0 35 0;
#X connect 35 0 37 0;
#X connect 36 0 35 1;
#X connect 37 0 40 0;
#X connect 38 0 40 0;
#X connect 40 0 39 0;
#X restore 27 235 pd random_seeds;
#X text 23 191 The "seed" gives the starting point of the random generator.
Have a look in here for more info:;
#N canvas 0 0 592 376 random_impulse_generator 0;
#X text 31 4 A RANDOM IMPULSE GENERATOR;
#X text 16 21 Some users might be familiar with SC (SuperCollider)
by James McCartney. For more info about SC \, visit www.audiosynth.com.
Anyways...SC has a unit generator called "DUST". Dust will produce
random impulses at a specified "density". I believe that Dust was given
its name because it creates a sound that is similar to actual dust
on old vinyl LP's -- you know that old crackling sound like Rice Krispies.
;
#X text 15 129 The idea is quite simple. If you want a "very dusty"
sound \, you make the density quite high...if you want a "slightly
dusty" sound \, you make the density quite low.;
#X text 15 174 Dust.ar(2) in SC will produce 2 dusty impulses randomly
per second. In the example below \, you'll see a version of this process
created using PD's delay object.;
#X obj 21 324 delay;
#X obj 21 346 bng 15 50 10 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 21 248 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 21 303 random 500;
#X obj 21 282 metro 500;
#X floatatom 86 248 5 0 0 0 - - -;
#X text 144 260 high numbers will produce a slightly "dusty" output.
;
#X text 144 275 Also note that this example merely approximates the
output of SC's "Dust" object.;
#X text 144 248 Low numbers will produce a very "dusty" output.;
#X connect 4 0 5 0;
#X connect 6 0 8 0;
#X connect 7 0 4 0;
#X connect 8 0 7 0;
#X connect 9 0 8 1;
#X connect 9 0 7 1;
#X restore 464 217 pd random_impulse_generator;
#N canvas 0 0 454 304 related_objects_from_other_libraries 0;
#X obj 25 23 randomF;
#X obj 87 23 tripleRand;
#X obj 166 23 shuffle;
#X obj 227 23 mtx_rand;
#X obj 169 47 pin~;
#X obj 25 47 randomblock~;
#X obj 119 47 utime;
#X text 14 104 These objects are offered in PD only if you have downloaded
and properly installed the appropriate library. These objects may or
may not exist in a single library.;
#X text 13 153 The best places to find information about PD's libraries
is:;
#X text 15 202 or;
#X text 15 219 http://iem.kug.ac.at/pdb/;
#X text 15 175 http://www.pure-data.info and click on "Downloads" then
"Software";
#X restore 463 135 pd related_objects_from_other_libraries;
#X text 463 92 Here are some other random objects from other external
libraries \, including Zexy:;
#X text 23 330 WEIGHTED RANDOM;
#N canvas 0 0 647 544 random_walk 0;
#X floatatom 113 218 5 0 0 0 - - -;
#X obj 123 113 f;
#X obj 104 198 random 4;
#X obj 26 197 random 2;
#X floatatom 35 219 5 0 0 0 - - -;
#X obj 123 138 t b b f;
#X obj 26 253 sel 0 1;
#X obj 159 328 +;
#X obj 123 87 metro 100;
#X obj 123 65 tgl 15 0 empty empty empty 0 -6 0 8 -262144 -1 -1 0 1
;
#X obj 104 252 + 1;
#X floatatom 242 153 5 0 0 0 - - -;
#X obj 82 309 *;
#X msg 26 282 -1;
#X obj 242 83 moses 0;
#X obj 316 83 moses 100;
#X obj 242 107 * -1;
#X obj 407 86 * -1;
#X obj 407 111 + 200;
#X msg 60 282 1;
#X text 39 9 Random walk generator;
#X text 143 64 on/off;
#X text 298 152 output;
#X text 22 375 A random walk is a special case of a Markov chain \,
in which the states are integers and the transitions add or subtract
a small amount from the previous state to get a new one. Here the "f"
holds the state. When it gets a bang \, the previous state is added
to a random number (from 1 to 4) multiplied by a random sign (-1 or
1). The new value is then coerced into the range from 0 to 100;
#X text 35 235 sign;
#X text 113 234 magnitude;
#X text 203 313 add prev value;
#X text 200 330 to random increment;
#X text 256 30 coercion to range 0-100 \; if out of range \, reflect
;
#X text 255 60 us back in.;
#X text 323 492 updated for Pd version 0.37-1;
#X connect 1 0 5 0;
#X connect 2 0 0 0;
#X connect 2 0 10 0;
#X connect 3 0 4 0;
#X connect 3 0 6 0;
#X connect 5 0 3 0;
#X connect 5 1 2 0;
#X connect 5 2 7 1;
#X connect 6 0 13 0;
#X connect 6 1 19 0;
#X connect 7 0 14 0;
#X connect 8 0 1 0;
#X connect 9 0 8 0;
#X connect 10 0 12 1;
#X connect 11 0 1 1;
#X connect 12 0 7 0;
#X connect 13 0 12 0;
#X connect 14 0 16 0;
#X connect 14 1 15 0;
#X connect 15 0 11 0;
#X connect 15 1 17 0;
#X connect 16 0 11 0;
#X connect 17 0 18 0;
#X connect 18 0 11 0;
#X connect 19 0 12 0;
#X restore 137 566 pd random_walk;
#N canvas 0 0 654 534 markov_chain 0;
#X obj 84 251 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 81 336 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 162 335 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 199 337 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X msg 81 358 1;
#X msg 162 360 2;
#X msg 199 361 3;
#X obj 81 386 s state;
#X obj 66 173 bng 20 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 105 164 r state;
#X obj 83 225 sel 1 2 3;
#X obj 255 253 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 252 338 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 334 340 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 373 343 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X msg 252 361 1;
#X msg 329 366 2;
#X msg 373 367 3;
#X obj 252 394 s state;
#X obj 419 254 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 419 339 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 499 338 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X obj 538 341 bng 15 250 50 0 empty empty empty 20 8 0 8 -262144 -1
-1;
#X msg 419 362 1;
#X msg 499 363 2;
#X msg 538 364 3;
#X obj 418 395 s state;
#X msg 236 186 \; state 1;
#X obj 83 199 f 1;
#X obj 84 279 random 100;
#X obj 83 308 moses 30;
#X obj 162 309 moses 60;
#X obj 255 280 random 100;
#X obj 255 310 moses 10;
#X obj 334 311 moses 60;
#X obj 419 281 random 100;
#X obj 419 310 moses 70;
#X obj 499 310 moses 80;
#X floatatom 134 188 3 0 0 0 - - -;
#X text 236 166 reset;
#X text 49 152 STEP;
#X text 34 20 Here is how to construct a simple \, three-valued Markov
chain using "random." Each time you click on "step" the previous output
("state") determines which of three random networks to invoke \, each
having a different probability distribution for the next value of "state."
For instance if the state was 3 \, the next state will be 1 70% of
the time \, state 2 10% \, and state 3 20%.;
#X text 408 422 updated for Pd version 0.35;
#X connect 0 0 29 0;
#X connect 1 0 4 0;
#X connect 2 0 5 0;
#X connect 3 0 6 0;
#X connect 4 0 7 0;
#X connect 5 0 7 0;
#X connect 6 0 7 0;
#X connect 8 0 28 0;
#X connect 9 0 28 1;
#X connect 9 0 38 0;
#X connect 10 0 0 0;
#X connect 10 1 11 0;
#X connect 10 2 19 0;
#X connect 11 0 32 0;
#X connect 12 0 15 0;
#X connect 13 0 16 0;
#X connect 14 0 17 0;
#X connect 15 0 18 0;
#X connect 16 0 18 0;
#X connect 17 0 18 0;
#X connect 19 0 35 0;
#X connect 20 0 23 0;
#X connect 21 0 24 0;
#X connect 22 0 25 0;
#X connect 23 0 26 0;
#X connect 24 0 26 0;
#X connect 25 0 26 0;
#X connect 28 0 10 0;
#X connect 29 0 30 0;
#X connect 30 0 1 0;
#X connect 30 1 31 0;
#X connect 31 0 2 0;
#X connect 31 1 3 0;
#X connect 32 0 33 0;
#X connect 33 0 12 0;
#X connect 33 1 34 0;
#X connect 34 0 13 0;
#X connect 34 1 14 0;
#X connect 35 0 36 0;
#X connect 36 0 20 0;
#X connect 36 1 37 0;
#X connect 37 0 21 0;
#X connect 37 1 22 0;
#X restore 25 566 pd markov_chain;
#X text 23 537 ADVANCED RANDOM: markov chains;
#X text 22 11 On each "bang" \, [random] outputs pseudorandom integers
between 0 and N-1 where N is the creation argument or the value of
the right inlet.;
#X text 463 177 Here is a random impulse generator built with the [delay]
object:;
#X obj 554 270 random_range 333 666;
#X text 131 267 This abstraction \, called "random_range.pd" \, can
be used to generate numbers within a range given by the creation arguments:
;
#X obj 554 248 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X floatatom 554 294 5 0 0 0 - - -;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 7 0 9 0;
#X connect 8 0 7 0;
#X connect 10 0 7 1;
#X connect 12 0 14 0;
#X connect 14 0 19 0;
#X connect 17 0 19 1;
#X connect 19 0 15 0;
#X connect 19 1 16 0;
#X connect 22 0 23 0;
#X connect 23 0 27 0;
#X connect 27 0 24 0;
#X connect 27 1 28 0;
#X connect 28 0 25 0;
#X connect 28 1 29 0;
#X connect 46 0 49 0;
#X connect 48 0 46 0;
